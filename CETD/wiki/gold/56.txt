
Fortran
Fortran

The Fortran Automatic Coding System for the IBM 704 (October 15, 1956), the first Programmer's Reference Manual for Fortran
Paradigm	multi-paradigm: imperative (procedural), structured, object-oriented, generic
Appeared in	1957
Designed by	John Backus
Developer	John Backus & IBM
Stable release	Fortran 2008 (ISO/IEC 1539-1:2010) (2010)
Typing discipline	strong, static, manifest
Major implementations	Absoft, Cray, GFortran, G95, IBM, Intel, Lahey/Fujitsu, Open Watcom, Pathscale, PGI, Silverfrost, Oracle, XL Fortran, Visual Fortran, others
Influenced by	Speedcoding
Influenced	ALGOL 58, BASIC, C, PL/I, PACT I, MUMPS, Ratfor
Usual file extensions	.f, .for, .f90, .f95
Fortran (previously FORTRAN;[note 1] both blends derived from IBM Mathematical Formula Translating System) is a general-purpose,[note 2] procedural,[note 3] imperative programming language that is especially suited to numeric computation and scientific computing. Originally developed by IBM at their campus in south San Jose, California[1] in the 1950s for scientific and engineering applications, Fortran came to dominate this area of programming early on and has been in continual use for over half a century in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics, computational physics and computational chemistry. It was one of the most popular languages in the area of high-performance computing[citation needed] and is the language used for programs that benchmark and rank the world's fastest supercomputers.
Fortran encompasses a lineage of versions, each of which evolved to add extensions to the language while usually retaining compatibility with previous versions. Successive versions have added support for processing of character-based data (FORTRAN 77), array programming, modular programming and object-based programming (Fortran 90 / 95), and object-oriented and generic programming (Fortran 2003).
Contents [hide]
1 History
1.1 FORTRAN
1.2 IBM 1401 FORTRAN
1.3 FORTRAN II
1.3.1 Simple FORTRAN II program
1.4 FORTRAN III
1.5 FORTRAN IV
1.6 FORTRAN 66
1.7 FORTRAN 77
1.7.1 Variants: Minnesota FORTRAN
2 Transition to ANSI Standard Fortran
2.1 Fortran 90
2.1.1 Obsolescence and deletions
2.2 Fortran 95
2.2.1 Conditional compilation and varying length strings
2.3 Fortran 2003
2.4 Fortran 2008
2.5 Legacy
3 Language features
4 Portability
5 Variants
5.1 Fortran 5
5.2 Fortran VI
5.3 Specific variants
5.3.1 FOR TRANSIT for the IBM 650
5.4 Fortran-based languages
6 Code examples
7 Humor
8 See also
9 Notes
10 References
11 Further reading
12 External links
[edit]History



An IBM 704 mainframe


FORTRAN code on a punched card, showing the specialized uses of columns 1-5, 6 and 73-80.
In late 1953, John W. Backus submitted a proposal to his superiors at IBM to develop a more practical alternative to assembly language for programming their IBM 704 mainframe computer. Backus' historic FORTRAN team consisted of programmers Richard Goldberg, Sheldon F. Best, Harlan Herrick, Peter Sheridan, Roy Nutt, Robert Nelson, Irving Ziller, Lois Haibt, and David Sayre.[2]
A draft specification for The IBM Mathematical Formula Translating System was completed by mid-1954. The first manual for FORTRAN appeared in October 1956, with the first FORTRAN compiler delivered in April 1957. This was an optimizing compiler, because customers were reluctant to use a high-level programming language unless its compiler could generate code whose performance was comparable to that of hand-coded assembly language.
While the community was skeptical that this new method could possibly out-perform hand-coding, it reduced the number of programming statements necessary to operate a machine by a factor of 20, and quickly gained acceptance. Said creator John Backus during a 1979 interview with Think, the IBM employee magazine, "Much of my work has come from being lazy. I didn't like writing programs, and so, when I was working on the IBM 701, writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs."[3]
The language was widely adopted by scientists for writing numerically intensive programs, which encouraged compiler writers to produce compilers that could generate faster and more efficient code. The inclusion of a complex number data type in the language made Fortran especially suited to technical applications such as electrical engineering.
By 1960, versions of FORTRAN were available for the IBM 709, 650, 1620, and 7090 computers. Significantly, the increasing popularity of FORTRAN spurred competing computer manufacturers to provide FORTRAN compilers for their machines, so that by 1963 over 40 FORTRAN compilers existed. For these reasons, FORTRAN is considered to be the first widely used programming language supported across a variety of computer architectures.
The development of FORTRAN paralleled the early evolution of compiler technology; indeed many advances in the theory and design of compilers were specifically motivated by the need to generate efficient code for FORTRAN programs.
[edit]FORTRAN
The initial release of FORTRAN for the IBM 704 contained 32 statements, including:
DIMENSION and EQUIVALENCE statements
Assignment statements
Three-way arithmetic IF statement.[note 4]
IF statements for checking exceptions (ACCUMULATOR OVERFLOW, QUOTIENT OVERFLOW, and DIVIDE CHECK); and IF statements for manipulating sense switches and sense lights
GOTO, computed GOTO, ASSIGN, and assigned GOTO
DO loops
Formatted I/O: FORMAT, READ, READ INPUT TAPE, WRITE, WRITE OUTPUT TAPE, PRINT, and PUNCH
Unformatted I/O: READ TAPE, READ DRUM, WRITE TAPE, and WRITE DRUM
Other I/O: END FILE, REWIND, and BACKSPACE
PAUSE, STOP, and CONTINUE
FREQUENCY statement (for providing optimization hints to the compiler).[note 5]
Before the development of disk files, text editors and terminals, programs were most often entered on a keypunch keyboard onto 80 column punched cards, one line to a card, which would be fed into a card reader in a batch. Originally programs were written in a "fixed" column format. Column 1 was the comment field, a letter C caused the entire card to be ignored by the compiler. Columns 2 to 5 were the label field: a sequence of digits here was taken as a label for the purpose of a GOTO or a FORMAT reference in a WRITE or READ statement. Column 6 was a continuation field: a non-blank character here caused the card to be taken as a continuation of the statement on the previous card. Columns 73 to 80 were ignored, so they were reserved for punching a sequence number which in theory could be used to re-order cards if a stack of cards was dropped, though in practice these were rarely so punched as re-assembling a stack would have to be done manually. Columns 7 to 72 served as the statement field. Later compilers relaxed these restrictions.
Early FORTRAN compilers did not support recursion in subroutines. Early computer architectures did not support the concept of a stack, and when they did directly support subroutine calls, the return location was often stored in a fixed location adjacent to the subroutine code which does not support more than one level of calling. Although not specified in Fortran 77, many F77 compilers supported recursion as an option, while it became a standard in Fortran 90.[4]
[edit]IBM 1401 FORTRAN
FORTRAN was provided for the IBM 1401 by an innovative 63-pass compiler that ran in only 8k of core. It kept the program in memory and loaded overlays that gradually transformed it, in place, into executable form, as described by Haines et al.[5] The executable form was not machine language; rather it was interpreted, anticipating UCSD Pascal P-code by two decades.
[edit]FORTRAN II
IBM's FORTRAN II appeared in 1958. The main enhancement was to support procedural programming by allowing user-written subroutines and functions which returned values, with parameters passed by reference. The COMMON statement provided a way for subroutines to access common (or global) variables. Six new statements were introduced:
SUBROUTINE, FUNCTION, and END
CALL and RETURN
COMMON
Over the next few years, FORTRAN II would also add support for the DOUBLE PRECISION and COMPLEX data types.
[edit]Simple FORTRAN II program
This program, for Heron's formula, reads one data card containing three 5-digit integers A, B, and C as input. If A, B, and C cannot represent the sides of a triangle in plane geometry, then the program's execution will end with an error code of "STOP 1". Otherwise, an output line will be printed showing the input values for A, B, and C, followed by the computed AREA of the triangle as a floating-point number with 2 digits after the decimal point.
C AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION 
C INPUT - CARD READER UNIT 5, INTEGER INPUT
C OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT
C INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING
      READ INPUT TAPE 5, 501, IA, IB, IC
  501 FORMAT (3I5)
C IA, IB, AND IC MAY NOT BE NEGATIVE
C FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE
C IS GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO
      IF (IA) 777, 777, 701
  701 IF (IB) 777, 777, 702
  702 IF (IC) 777, 777, 703
  703 IF (IA+IB-IC) 777,777,704
  704 IF (IA+IC-IB) 777,777,705
  705 IF (IB+IC-IA) 777,777,799
  777 STOP 1
C USING HERON'S FORMULA WE CALCULATE THE
C AREA OF THE TRIANGLE
  799 S = FLOATF (IA + IB + IC) / 2.0
      AREA = SQRT( S * (S - FLOATF(IA)) * (S - FLOATF(IB)) *
     +     (S - FLOATF(IC)))
      WRITE OUTPUT TAPE 6, 601, IA, IB, IC, AREA
  601 FORMAT (4H A= ,I5,5H  B= ,I5,5H  C= ,I5,8H  AREA= ,F10.2, 
     +        13H SQUARE UNITS)
      STOP
      END
[edit]FORTRAN III


A FORTRAN coding form, formerly printed on paper and intended to be used by programmers to prepare programs for punching onto cards by keypunch operators. Now obsolete.
IBM also developed a FORTRAN III in 1958 that allowed for inline assembler code among other features; however, this version was never released as a product. Like the 704 FORTRAN and FORTRAN II, FORTRAN III included machine-dependent features that made code written in it unportable from machine to machine. Early versions of FORTRAN provided by other vendors suffered from the same disadvantage.
[edit]FORTRAN IV
Starting in 1961, as a result of customer demands, IBM began development of a FORTRAN IV that removed the machine-dependent features of FORTRAN II (such as READ INPUT TAPE), while adding new features such as a LOGICAL data type, logical Boolean expressions and the logical IF statement as an alternative to the arithmetic IF statement. FORTRAN IV was eventually released in 1962, first for the IBM 7030 ("Stretch") computer, followed by versions for the IBM 7090 and IBM 7094.
By 1965, Fortran IV was supposed to be the "standard" and in compliance with American Standards Association X3.4.3 FORTRAN Working Group.[6]
[edit]FORTRAN 66
Perhaps the most significant development in the early history of FORTRAN was the decision by the American Standards Association (now ANSI) to form a committee to develop an "American Standard Fortran." The resulting two standards, approved in March 1966, defined two languages, FORTRAN (based on FORTRAN IV, which had served as a de facto standard), and Basic FORTRAN (based on FORTRAN II, but stripped of its machine-dependent features). The FORTRAN defined by the first standard became known as FORTRAN 66 (although many continued to refer to it as FORTRAN IV, the language upon which the standard was largely based). FORTRAN 66 effectively became the first "industry-standard" version of FORTRAN. FORTRAN 66 included:
Main program, SUBROUTINE, FUNCTION, and BLOCK DATA program units
INTEGER, REAL, DOUBLE PRECISION, COMPLEX, and LOGICAL data types
COMMON, DIMENSION, and EQUIVALENCE statements
DATA statement for specifying initial values
Intrinsic and EXTERNAL (e.g., library) functions
Assignment statement
GOTO, assigned GOTO, and computed GOTO statements
Logical IF and arithmetic (three-way) IF statements
DO loops
READ, WRITE, BACKSPACE, REWIND, and ENDFILE statements for sequential I/O
FORMAT statement
CALL, RETURN, PAUSE, and STOP statements
Hollerith constants in DATA and FORMAT statements, and as actual arguments to procedures
Identifiers of up to six characters in length
Comment lines
[edit]FORTRAN 77
After the release of the FORTRAN 66 standard, compiler vendors introduced a number of extensions to "Standard Fortran", prompting ANSI in 1969 to begin work on revising the 1966 standard. Final drafts of this revised standard circulated in 1977, leading to formal approval of the new FORTRAN standard in April 1978. The new standard, known as FORTRAN 77, added a number of significant features to address many of the shortcomings of FORTRAN 66:
Block IF and END IF statements, with optional ELSE and ELSE IF clauses, to provide improved language support for structured programming
DO loop extensions, including parameter expressions, negative increments, and zero trip counts
OPEN, CLOSE, and INQUIRE statements for improved I/O capability
Direct-access file I/O
IMPLICIT statement
CHARACTER data type, with vastly expanded facilities for character input and output and processing of character-based data
PARAMETER statement for specifying constants
SAVE statement for persistent local variables
Generic names for intrinsic functions
A set of intrinsics (LGE, LGT, LLE, LLT) for lexical comparison of strings, based upon the ASCII collating sequence.
(ASCII functions were demanded by the U.S. Department of Defense, in their conditional approval vote.)
In this revision of the standard, a number of features were removed or altered in a manner that might invalidate previously standard-conforming programs. (Removal was the only allowable alternative to X3J3 at that time, since the concept of "deprecation" was not yet available for ANSI standards.) While most of the 24 items in the conflict list (see Appendix A2 of X3.9-1978) addressed loopholes or pathological cases permitted by the previous standard but rarely used, a small number of specific capabilities were deliberately removed, such as:
Hollerith constants and Hollerith data, such as:
GREET = 12HHELLO THERE!
Reading into a H edit (Hollerith field) descriptor in a FORMAT specification.
Overindexing of array bounds by subscripts.
DIMENSION A(10,5)
Y= A(11,1)
Transfer of control into the range of a DO loop (also known as "Extended Range").
[edit]Variants: Minnesota FORTRAN
Control Data Corporation computers had another version of FORTRAN 77, called Minnesota FORTRAN (MNF), designed especially for student use, with variations in output constructs, special uses of COMMONs and DATA statements, optimizations code levels for compiling, and detailed error listings, extensive warning messages, and debugs.[7]
[edit]Transition to ANSI Standard Fortran

The development of a revised standard to succeed FORTRAN 77 would be repeatedly delayed as the standardization process struggled to keep up with rapid changes in computing and programming practice. In the meantime, as the "Standard FORTRAN" for nearly fifteen years, FORTRAN 77 would become the historically most important dialect.

An important practical extension to FORTRAN 77 was the release of MIL-STD-1753 in 1978.[8] This specification, developed by the U.S. Department of Defense, standardized a number of features implemented by most FORTRAN 77 compilers but not included in the ANSI FORTRAN 77 standard. These features would eventually be incorporated into the Fortran 90 standard.
DO WHILE and END DO statements
INCLUDE statement
IMPLICIT NONE variant of the IMPLICIT statement
Bit manipulation intrinsic functions, based on similar functions included in Industrial Real-Time Fortran (ANSI/ISA S61.1 (1976))
The IEEE 1003.9 POSIX Standard, released in 1991, provided a simple means for FORTRAN 77 programmers to issue POSIX system calls.[9] Over 100 calls were defined in the document — allowing access to POSIX-compatible process control, signal handling, file system control, device control, procedure pointing, and stream I/O in a portable manner.
[edit]Fortran 90
The much delayed successor to FORTRAN 77, informally known as Fortran 90 (and prior to that, Fortran 8X), was finally released as an ISO standard in 1991 and an ANSI Standard in 1992. This major revision added many new features to reflect the significant changes in programming practice that had evolved since the 1978 standard:
Free-form source input, also with lowercase Fortran keywords
Identifiers up to 31 characters in length
Inline comments
Ability to operate on arrays (or array sections) as a whole, thus greatly simplifying math and engineering computations.
whole, partial and masked array assignment statements and array expressions, such as   X(1:N)=R(1:N)*COS(A(1:N))
WHERE statement for selective array assignment
array-valued constants and expressions,
user-defined array-valued functions and array constructors.
RECURSIVE procedures
Modules, to group related procedures and data together, and make them available to other program units, including the capability to limit the accessibility to only specific parts of the module.
A vastly improved argument-passing mechanism, allowing interfaces to be checked at compile time
User-written interfaces for generic procedures
Operator overloading
Derived/abstract data types
New data type declaration syntax, to specify the data type and other attributes of variables
Dynamic memory allocation by means of the ALLOCATABLE attribute and the ALLOCATE and DEALLOCATE statements
POINTER attribute, pointer assignment, and NULLIFY statement to facilitate the creation and manipulation of dynamic data structures
Structured looping constructs, with an END DO statement for loop termination, and EXIT and CYCLE statements for "breaking out" of normal DO loop iterations in an orderly way
SELECT . . . CASE construct for multi-way selection
Portable specification of numerical precision under the user's control
New and enhanced intrinsic procedures.
[edit]Obsolescence and deletions
Unlike the previous revision, Fortran 90 did not delete any features. (Appendix B.1 says, "The list of deleted features in this standard is empty.") Any standard-conforming FORTRAN 77 program is also standard-conforming under Fortran 90, and either standard should be usable to define its behavior.
A small set of features were identified as "obsolescent" and expected to be removed in a future standard.
Obsolescent feature	Example	Status / Fate in Fortran 95
Arithmetic IF-statement	    IF (X) 10, 20, 30	
Non-integer DO parameters or control variables	    DO 9 X= 1.7, 1.6, -0.1	Deleted
Shared DO-loop termination or
termination with a statement
other than END DO or CONTINUE  	    DO 9 J= 1, 10
        DO 9 K= 1, 10
9   L= J + K
Branching to END IF
from outside a block
66  GO TO 77 ; . . .
    IF (E) THEN ;     . . .
77  END IF
Deleted
Alternate return	    CALL SUBR( X, Y *100, *200 )	
PAUSE statement	    PAUSE 600	Deleted
ASSIGN statement
  and assigned GO TO statement	100  . . .
    ASSIGN 100 TO H
    . . .
    GO TO H . . .
Deleted
Assigned FORMAT specifiers	    ASSIGN F TO 606	Deleted
H edit descriptors	606 FORMAT ( 9H1GOODBYE. )	Deleted
Computed GO TO statement	    GO TO (10, 20, 30, 40), index	(Obso.)
Statement functions	    FOIL( X, Y )= X**2 + 2*X*Y + Y**2	(Obso.)
DATA statements
  among executable statements	    X= 27.3
    DATA A, B, C / 5.0, 12.0. 13.0 /     . . .
(Obso.)
CHARACTER* form of CHARACTER declaration	    CHARACTER*8 STRING   ! Use CHARACTER(8)	(Obso.)
Assumed character length functions	
Fixed form source code	* Column 1 contains * or ! or C for comments.
C       Column 6 for continuation.	
[edit]Fortran 95
Fortran 95 was a minor revision, mostly to resolve some outstanding issues from the Fortran 90 standard. Nevertheless, Fortran 95 also added a number of extensions, notably from the High Performance Fortran specification:
FORALL and nested WHERE constructs to aid vectorization
User-defined PURE and ELEMENTAL procedures
Default initialization of derived type components, including pointer initialization
Expanded the ability to use initialization expressions for data objects
Clearly defined that ALLOCATABLE arrays are automatically deallocated when they go out of scope.
A number of intrinsic functions were extended (for example a dim argument was added to the maxloc intrinsic).
Several features noted in Fortran 90 to be deprecated were removed from Fortran 95:
DO statements using REAL and DOUBLE PRECISION variables
Branching to an END IF statement from outside its block
PAUSE statement
ASSIGN and assigned GOTO statement, and assigned format specifiers
H edit descriptor.
An important supplement to Fortran 95 was the ISO technical report TR-15581: Enhanced Data Type Facilities, informally known as the Allocatable TR. This specification defined enhanced use of ALLOCATABLE arrays, prior to the availability of fully Fortran 2003-compliant Fortran compilers. Such uses include ALLOCATABLE arrays as derived type components, in procedure dummy argument lists, and as function return values. (ALLOCATABLE arrays are preferable to POINTER-based arrays because ALLOCATABLE arrays are guaranteed by Fortran 95 to be deallocated automatically when they go out of scope, eliminating the possibility of memory leakage. In addition, aliasing is not an issue for optimization of array references, allowing compilers to generate faster code than in the case of pointers.)
Another important supplement to Fortran 95 was the ISO technical report TR-15580: Floating-point exception handling, informally known as the IEEE TR. This specification defined support for IEEE floating-point arithmetic and floating point exception handling.
[edit]Conditional compilation and varying length strings
In addition to the mandatory "Base language" (defined in ISO/IEC 1539-1 : 1997), the Fortran 95 language also includes two optional modules:
Varying character strings (ISO/IEC 1539-2 : 2000)
Conditional compilation (ISO/IEC 1539-3 : 1998)
which, together, comprise the multi-part International Standard (ISO/IEC 1539).
According to the standards developers, "the optional parts describe self-contained features which have been requested by a substantial body of users and/or implementors, but which are not deemed to be of sufficient generality for them to be required in all standard-conforming Fortran compilers." Nevertheless, if a standard-conforming Fortran does provide such options, then they "must be provided in accordance with the description of those facilities in the appropriate Part of the Standard."
[edit]Fortran 2003
Fortran 2003 is a major revision introducing many new features. A comprehensive summary of the new features of Fortran 2003 is available at the Fortran Working Group (WG5) official Web site.[10]
From that article, the major enhancements for this revision include:
Derived type enhancements: parameterized derived types, improved control of accessibility, improved structure constructors, and finalizers.
Object-oriented programming support: type extension and inheritance, polymorphism, dynamic type allocation, and type-bound procedures.
Data manipulation enhancements: allocatable components (incorporating TR 15581), deferred type parameters, VOLATILE attribute, explicit type specification in array constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures.
Input/output enhancements: asynchronous transfer, stream access, user specified transfer operations for derived types, user specified control of rounding during format conversions, named constants for preconnected units, the FLUSH statement, regularization of keywords, and access to error messages.
Procedure pointers.
Support for IEEE floating-point arithmetic and floating point exception handling (incorporating TR 15580).
Interoperability with the C programming language.
Support for international usage: access to ISO 10646 4-byte characters and choice of decimal or comma in numeric formatted input/output.
Enhanced integration with the host operating system: access to command line arguments, environment variables, and processor error messages.
An important supplement to Fortran 2003 was the ISO technical report TR-19767: Enhanced module facilities in Fortran. This report provided submodules, which make Fortran modules more similar to Modula-2 modules. They are similar to Ada private child subunits. This allows the specification and implementation of a module to be expressed in separate program units, which improves packaging of large libraries, allows preservation of trade secrets while publishing definitive interfaces, and prevents compilation cascades.
[edit]Fortran 2008
The most recent standard, ISO/IEC 1539-1:2010, informally known as Fortran 2008, was approved in September 2010 [11]. As with Fortran 95, this is a minor upgrade, incorporating clarifications and corrections to Fortran 2003, as well as introducing a select few new capabilities. The new capabilities include:
Submodules – Additional structuring facilities for modules; supersedes ISO/IEC TR 19767:2005
Co-array Fortran – a parallel execution model
The DO CONCURRENT construct – for loop iterations with no interdependencies
The CONTIGUOUS attribute – to specify storage layout restrictions
The BLOCK construct – can contain declarations of objects with construct scope
Recursive allocatable components – as an alternative to recursive pointers in derived types
The Final Draft international Standard (FDIS) is available as document N1830[12].
[edit]Legacy
Since Fortran has been in use for more than fifty years, there is a vast body of Fortran in daily use throughout the scientific and engineering communities. It is the primary language for some of the most intensive supercomputing tasks, such as weather and climate modeling, computational fluid dynamics, computational chemistry, computational economics, animal breeding, plant breeding and computational physics. Even today, half a century later, many of the floating-point benchmarks to gauge the performance of new computer processors are still written in Fortran (e.g., CFP2006, the floating-point component of the SPEC CPU2006 benchmarks).
[edit]Language features

Main article: Fortran language features
[edit]Portability

Portability was a problem in the early days because there was no agreed standard—not even IBM's reference manual—and computer companies vied to differentiate their offerings from others by providing incompatible features. Standards have improved portability. The 1966 standard provided a reference syntax and semantics, but vendors continued to provide incompatible extensions. Although careful programmers were coming to realize that use of incompatible extensions caused expensive portability problems, and were therefore using programs such as The PFORT Verifier, it was not until after the 1977 standard, when the National Bureau of Standards (now NIST) published FIPS PUB 69, that processors purchased by the U.S. Government were required to diagnose extensions of the standard. Rather than offer two processors, essentially every compiler eventually had at least an option to diagnose extensions.
Incompatible extensions were not the only portability problem. For numerical calculations, it is important to take account of the characteristics of the arithmetic. This was addressed by Fox et al. in the context of the 1966 standard by the PORT library. The ideas therein became widely used, and were eventually incorporated into the 1990 standard by way of intrinsic inquiry functions. The widespread (now almost universal) adoption of the IEEE 754 standard for binary floating-point arithmetic has essentially removed this problem.
Access to the computing environment (e.g. the program's command line, environment variables, textual explanation of error conditions) remained a problem until it was addressed by the 2003 standard.
Large collections of "library" software that could be described as being loosely related to engineering and scientific calculations, such as graphics libraries, have been written in C, and therefore access to them presented a portability problem. This has been addressed by incorporation of C interoperability into the 2003 standard.
It is now possible (and relatively easy) to write an entirely portable program in Fortran, even without recourse to a preprocessor.
[edit]Variants

[edit]Fortran 5
Fortran 5 was a programming language marketed by Data General Corp in the late 1970s and early 80s, for the Nova, Eclipse, and MV line of computers. It had an optimizing compiler that was quite good for minicomputers of its time. The language most closely resembles Fortran 66. The name is a pun on the earlier Fortran IV.
Univac also offered a compiler for the 1100 series known as Fortran V. A spinoff of Univac Fortran V was Athena Fortran.
[edit]Fortran VI
Fortran VI was a programming language distributed by Control Data Corporation in 1968 for the CDC 6600 series. The language was based upon Fortran IV.[13]
[edit]Specific variants
Vendors of high-performance scientific computers (e.g., Burroughs, CDC, Cray, Honeywell, IBM, Texas Instruments, and UNIVAC) added extensions to Fortran to take advantage of special hardware features such as instruction cache, CPU pipelines, and vector arrays. For example, one of IBM's FORTRAN compilers (H Extended IUP) had a level of optimization which reordered the machine code instructions to keep multiple internal arithmetic units busy simultaneously. Another example is CFD, a special variant of Fortran designed specifically for the ILLIAC IV supercomputer, running at NASA's Ames Research Center. IBM Research Labs also developed an extended FORTRAN-based language called "VECTRAN" for processing of vectors and matrices.
Object-Oriented Fortran was an object-oriented extension of Fortran, in which data items can be grouped into objects, which can be instantiated and executed in parallel. It was available for Sun, Iris, iPSC, and nCUBE, but is no longer supported.
Such machine-specific extensions have either disappeared over time or have had elements incorporated into the main standards; the major remaining extension is OpenMP, which is a cross-platform extension for shared memory programming. One new extension, Co-array Fortran, is intended to support parallel programming.
[edit]FOR TRANSIT for the IBM 650
"FOR TRANSIT" was the name of a reduced version of the IBM 704 FORTRAN language, which was implemented for the IBM 650, using a translator program developed at Carnegie [14] in the late 1950s. The following comment appears in the IBM Reference Manual ("FOR TRANSIT Automatic Coding System" C28-4038, Copyright 1957, 1959 by IBM):
The FORTRAN system was designed for a more complex machine than the 650, and consequently some of the 32 statements found in the FORTRAN Programmer's Reference Manual are not acceptable to the FOR TRANSIT system. In addition, certain restrictions to the FORTRAN language have been added. However, none of these restrictions make a source program written for FOR TRANSIT incompatible with the FORTRAN system for the 704.
The permissible statements were:
Arithmetic assignment statements, e.g. a = b
GO to n
GO TO (n1, n2, ..., nm), i
IF (a) n1, n2, n3
PAUSE
STOP
DO n i = m1, m2
CONTINUE
END
READ n, list
PUNCH n, list
DIMENSION V, V, V, ...
EQUIVALENCE (a,b,c), (d,c), ...
Up to ten subroutines could be used in one program.
FOR TRANSIT statements were limited to columns 7 thru 56, only. Punched cards were used for input and output on the IBM 650. Three passes were required to translate source code to the "IT" language, then to compile the IT statements into SOAP assembly language, and finally to produce the object program, which could then be loaded into the machine to run the program (using punched cards for data input, and outputting results onto punched cards.)
Two versions existed for the 650s with a 2000 word memory drum: FOR TRANSIT I (S) and FOR TRANSIT II, the latter for machines equipped with indexing registers and automatic floating point decimal (bi-quinary) arithmetic. Appendix A of the manual included wiring diagrams for the IBM 533 control panel.
[edit]Fortran-based languages
Prior to FORTRAN 77, a number of preprocessors were commonly used to provide a friendlier language, with the advantage that the preprocessed code could be compiled on any machine with a standard FORTRAN compiler. Popular preprocessors included FLECS, MORTRAN, SFtran, S-Fortran, Ratfor, and Ratfiv. (Ratfor and Ratfiv, for example, implemented a remarkably C-like language, outputting preprocessed code in standard FORTRAN 66.[note 6])
LRLTRAN was developed at the Lawrence Radiation Laboratory to provide support for vector arithmetic and dynamic storage, among other extensions to support systems programming. The distribution included the LTSS operating system.
The Fortran-95 Standard includes an optional Part 3 which defines an optional conditional compilation capability. This capability is often referred to as "CoCo".
Many Fortran compilers have integrated subsets of the C preprocessor into their systems.
SIMSCRIPT is an application specific Fortran preprocessor for modeling and simulating large discrete systems.
The F programming language was designed to be a clean subset of Fortran 95 that attempted to remove the redundant, unstructured, and deprecated features of Fortran, such as the EQUIVALENCE statement. F retains the array features added in Fortran 90, and removes control statements that were obsoleted by structured programming constructs added to both Fortran 77 and Fortran 90. F is described by its creators as "a compiled, structured, array programming language especially well suited to education and scientific computing."[15]
[edit]Code examples

For more details on this topic, see Wikibooks:Fortran/Fortran examples.
The following program illustrates dynamic memory allocation and array-based operations, two features introduced with Fortran 90. Particularly noteworthy is the absence of DO loops and IF/THEN statements in manipulating the array; mathematical operations are applied to the array as a whole. Also apparent is the use of descriptive variable names and general code formatting that conform with contemporary programming style. This example computes an average over data entered interactively.
program average
 
  ! Read in some numbers and take the average
  ! As written, if there are no data points, an average of zero is returned
  ! While this may not be desired behavior, it keeps this example simple
 
  implicit none
 
  real, dimension(:), allocatable :: points
  integer                         :: number_of_points
  real                            :: average_points=0., positive_average=0., negative_average=0.
 
  write (*,*) "Input number of points to average:"
  read  (*,*) number_of_points
 
  allocate (points(number_of_points))
 
  write (*,*) "Enter the points to average:"
  read  (*,*) points
 
  ! Take the average by summing points and dividing by number_of_points
  if (number_of_points > 0) average_points = sum(points) / number_of_points
 
  ! Now form average over positive and negative points only
  if (count(points > 0.) > 0) then
     positive_average = sum(points, points > 0.) / count(points > 0.)
  end if
 
  if (count(points < 0.) > 0) then
     negative_average = sum(points, points < 0.) / count(points < 0.)
  end if
 
  deallocate (points)
 
  ! Print result to terminal
  write (*,'(a,g12.4)') 'Average = ', average_points
  write (*,'(a,g12.4)') 'Average of positive points = ', positive_average
  write (*,'(a,g12.4)') 'Average of negative points = ', negative_average
 
end program average
[edit]Humor

During the same Fortran Standards Committee meeting at which the name "FORTRAN 77" was chosen, a technical proposal was incorporated into the official distribution, bearing the title, "Letter O considered harmful". This proposal purported to address the confusion that sometimes arises between the letter "O" and the numeral zero, by eliminating the letter from allowable variable names. However, the method proposed was to eliminate the letter from the character set entirely (thereby retaining 48 as the number of lexical characters, which the colon had increased to 49). This was considered beneficial in that it would promote structured programming, by making it impossible to use the notorious GO TO statement as before (Troublesome FORMAT statements would also be eliminated). It was noted that this "might invalidate some existing programs" but that most of these "probably were non-conforming, anyway".[16][17]
During the standards committee battle over whether the "minimum trip count" for the FORTRAN 77 "DO" statement should be zero (allowing no execution of the block) or one (the "plunge-ahead" DO), another facetious alternative was proposed (by Loren Meissner) to have the minimum trip be two -- since there is no need for a loop if it is only executed once.
[edit]See also

History of compiler writing
List of programming languages
List of Fortran numerical libraries
[edit]Notes

^ The names of earlier versions of the language through FORTRAN 77 were conventionally spelled in all-caps (FORTRAN 77 was the version in which the use of lowercase letters in keywords was strictly nonstandard). The capitalization has been dropped in referring to newer versions beginning with Fortran 90. The official language standards now refer to the language as "Fortran." Because the capitalization (or lack thereof) of the word FORTRAN was never 100% consistent in actual usage, and because many hold impassioned beliefs on the issue, this article, rather than attempt to be normative, adopts the convention of using the all-caps FORTRAN in referring to versions of FORTRAN through FORTRAN 77 and the title-caps Fortran in referring to versions of Fortran from Fortran 90 onward. This convention is reflected in the capitalization of FORTRAN in the ANSI X3.9-1966 (FORTRAN 66) and ANSI X3.9-1978 (FORTRAN 77) standards and the title caps Fortran in the ANSI X3.198-1992 (Fortran 90), ISO/IEC 1539-1:1997 (Fortran 95) and ISO/IEC 1539-1:2004 (Fortran 2003) standards.
^ Since FORTRAN 77, which introduced the CHARACTER data type.
^ Since FORTRAN II (1958).
^ Note: It is commonly believed that this statement corresponded to a three-way branch instruction on the IBM 704. This is not true, the 704 branch instructions all contained only one destination address (e.g., TZE — Transfer AC Zero, TNZ — Transfer AC Not Zero, TPL — Transfer AC Plus, TMI — Transfer AC Minus). The machine (and its successors in the 700/7000 series) did have a three-way skip instruction (CAS — Compare AC with Storage), which was probably the origin of this belief, but using this instruction to implement the IF would consume 4 instruction words, require the constant Zero in a word of storage, and take 3 machine cycles to execute; using the Transfer instructions to implement the IF could be done in 1 to 3 instruction words, required no constants in storage, and take 1 to 3 machine cycles to execute. An optimizing compiler like FORTRAN would most likely select the more compact and usually faster Transfers instead of the Compare (use of Transfers also allowed the FREQUENCY statement to optimize IFs, which could not be done using the Compare). Also the Compare considered −0 and +0 to be different values while the Transfer Zero and Transfer Not Zero considered them to be the same.
^ The FREQUENCY statement in FORTRAN was used originally and optionally to give branch probabilities for the three branch cases of the Arithmetic IF statement to bias the way code was generated and order of the basic blocks of code generated, in the global optimisation sense, were arranged in memory for optimality. The first FORTRAN compiler used this weighting to do a Monte Carlo simulation of the run-time generated code at compile time. It was very sophisticated for its time. This technique is documented in the original article in 1957 on the first FORTRAN compiler implementation by J. Backus, et al. Many years later, the FREQUENCY statement had no effect on the code, and was treated as a comment statement, since the compilers no longer did this kind of compile-time simulation. Below is a part of the 1957 paper, "The FORTRAN Automatic Coding System" by Backus, et al., with this snippet on the FREQUENCY statement and its use in a compile-time Monte Carlo simulation of the run-time to optimise the code generated. Quoting …
The fundamental unit of program is the basic block; a basic block is a stretch of program which has a single entry point and a single exit point. The purpose of section 4 is to prepare for section 5 a table of predecessors (PRED table) which enumerates the basic blocks and lists for every basic block each of the basic blocks which can be its immediate predecessor in flow, together with the absolute frequency of each such basic block link. This table is obtained by an actual "execution" of the program in Monte-Carlo fashion, in which the outcome of conditional transfers arising out of IF-type statements and computed GO TO'S is determined by a random number generator suitably weighted according to whatever FREQUENCY statements have been provided.
^ This is not altogether surprising, as Brian Kernighan, one of the co-creators of Ratfor, is also co-author of The C Programming Language.
[edit]References

^ "Math 169 Notes - Santa Clara University". http://math.scu.edu/~dsmolars/ma169/notesfortran.html.
^ Softwarepreservation.org
^ Fortran creator John Backus dies - Gadgets - MSNBC.com, MSN.com
^ http://www.ibiblio.org/pub/languages/fortran/ch1-12.html
^ Haines, L. H. (1965). "Serial compilation and the 1401 FORTRAN compiler". IBM Systems Journal 4 (1): 73–80. doi:10.1147/sj.41.0073. http://domino.research.IBM.com/tchjr/journalindex.nsf/495f80c9d0f539778525681e00724804/cde711e5ad6786e485256bfa00685a03?OpenDocument. This article was reprinted, edited, in both editions of Lee, John A. N. (1967(1st), 1974(2nd)). Anatomy of a Compiler. Van Nostrand Reinhold.
^ McCracken, Daniel D. (1965). "Preface". A Guide to FORTRAN IV Programming. New York: Wiley. p. v. ISBN 0-471-58281-6.
^ Chilton Computing with FORTRAN, Chilton-computing.org.uk
^ MIL-STD-1753. DoD Supplement to X3.9-1978. United States Government Printing Office. http://www.fortran.com/fortran/mil_std_1753.html.
^ POSIX 1003.9-1992. POSIX FORTRAN 77 Language Interface – Part 1: Binding for System Application Program Interface API. IEEE. http://standards.ieee.org/reading/ieee/std_public/description/posix/1003.9-1992_desc.html.
^ Fortran Working Group (WG5). It may also be downloaded as a PDF file or gzipped PostScript file, FTP.nag.co.uk
^ N1836, Summary of Voting/Table of Replies on ISO/IEC FDIS 1539-1, Information technology - Programming languages - Fortran - Part 1: Base language ftp://ftp.nag.co.uk/sc22wg5/N1801-N1850/N1836.pdfPDF ( 101 KiB)
^ N1830, Information technology — Programming languages — Fortran — Part 1: Base language ftp://ftp.nag.co.uk/sc22wg5/N1801-N1850/N1830.pdfPDF ( 7.9 MiB)
^ Healy, MJR (1968). "Towards FORTRAN VI". Advanced scientific Fortran by CDC. CDC. pp. 169–172. http://hopl.murdoch.edu.au/showlanguage.prx?exp=1092&language=CDC%20Fortran. Retrieved 2009-04-10.
^ "Internal Translator (IT) A Compiler for the IBM 650", by A. J. Perlis, J. W. Smith, and H. R. Van Zoeren, Computation Center, Carnegie Institute of Technology
^ "F Programming Language Homepage". http://www.fortran.com/F/index.html.
^ X3J3 post-meeting distribution for meeting held at Brookhaven National Laboratory in November 1976.
^ "The obliteration of O", Computer Weekly, March 3, 1977
[edit]Further reading

Articles
Backus, J. W.; H. Stern, I. Ziller, R. A. Hughes, R. Nutt, R. J. Beeber, S. Best, R. Goldberg, L. M. Haibt, H. L. Herrick, R. A. Nelson, D. Sayre, P. B. Sheridan (1957). "The FORTRAN Automatic Coding System". Western joint computer conference: Techniques for reliability (Los Angeles, California: Institute of Radio Engineers, American Institute of Electrical Engineers, ACM): 188–198. doi:10.1145/1455567.1455599.
Allen, F.E. (September 1981). "A History of Language Processor Technology in IBM". IBM Journal of Research and Development (IBM) 25 (5). http://www.research.ibm.com/journal/rd/255/ibmrd2505Q.pdf.
Roberts, Mark L.; Griffiths, Peter D. (1985). "Design Considerations for IBM Personal Computer Professional FORTRAN, an Optimizing Compiler". IBM Systems Journal (IBM) 24 (1): 49–60. doi:10.1147/sj.241.0049. http://www.research.ibm.com/journal/sj/241/ibmsj2401G.pdf.
Pigott, Diarmuid (2006). "FORTRAN - Backus et al high-level compiler (Computer Language)". The Encyclopedia of Computer Languages. Murdoch University. http://hopl.murdoch.edu.au/showlanguage.prx?exp=8&language=FORTRAN. Retrieved 2010-05-05.
Chivers, Ian D.; Sleightholme, Jane (2009). "Compiler support for the Fortran 2003 standard". ACM SIGPLAN Fortran Forum (ACM) 28 (1): 26–28. doi:10.1145/1520752.1520755. ISSN 10617264. http://www.fortranplus.co.uk/resources/fortran_2003_2008_compiler_support.pdf.
"Core" language standards
ANSI X3.9-1966. USA Standard FORTRAN. American National Standards Institute. http://www.fh-jena.de/~kleine/history/languages/ansi-x3dot9-1966-Fortran66.pdf. Informally known as FORTRAN 66.
ANSI X3.9-1978. American National Standard – Programming Language FORTRAN. American National Standards Institute. http://www.fortran.com/fortran/F77_std/rjcnf.html. Also known as ISO 1539-1980, informally known as FORTRAN 77.
ANSI X3.198-1992 (R1997) / ISO/IEC 1539:1991. American National Standard – Programming Language Fortran Extended. American National Standards Institute / ISO/IEC. http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=17366. Informally known as Fortran 90.
ISO/IEC 1539-1:1997. Information technology – Programming languages – Fortran – Part 1: Base language. http://j3-fortran.org/doc/standing/archive/007/97-007r2/pdf/97-007r2.pdf. Informally known as Fortran 95. There are a further two parts to this standard. Part 1 has been formally adopted by ANSI.
ISO/IEC 1539-1:2004. Information technology – Programming languages – Fortran – Part 1: Base language. http://www.dkuug.dk/jtc1/sc22/open/n3661.pdf. Informally known as Fortran 2003.
ISO/IEC 1539-1:2010 (Final Draft International Standard). Information technology – Programming languages – Fortran – Part 1: Base language. ftp://ftp.nag.co.uk/sc22wg5/N1801-N1850/N1830.pdf. Informally known as Fortran 2008.
Related standards
Kneis, Wilfried (October 1981). "Draft standard Industrial Real-Time FORTRAN". ACM SIGPLAN Notices (ACM Press) 16 (7): 45–60. doi:10.1145/947864.947868. ISSN 0362-1340.
ISO 8651-1:1988 Information processing systems—Computer graphics—Graphical Kernel System (GKS) language bindings—Part 1: FORTRAN. Geneva, Switzerland: ISO. 1988. http://www.iso.org/iso/catalogue_detail?csnumber=16024.
Textbooks

This article's further reading may not follow Wikipedia's content policies or guidelines. Please improve this article by removing excessive, less relevant or many publications with the same point of view; or by incorporating the relevant publications into the body of the article through appropriate citations. (August 2010)
McCracken, Daniel D. (1961). A Guide to FORTRAN Programming. New York: Wiley. LCCN 61-016618.
Page, Clive G. (1988). Professional Programmer's Guide to Fortran77 (7th June 2005 ed.). London: Pitman. ISBN 0-273-02856-1. http://www.star.le.ac.uk/~cgp/prof77.html. Retrieved 2010-05-04.
Etter, D. M. (1990). Structured FORTRAN 77 for Engineers and Scientists (3rd ed.). The Benjamin/Cummings Publishing Company, Inc.. ISBN 0-8053-0051-1.
Sleighthome, Jane; Chivers, Ian David (1990). Interactive Fortran 77: A Hands-On Approach. Computers and their applications (2nd ed.). Chichester: E. Horwood. ISBN 0-13-466764-6. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.95.9503.
Ellis, T. M. R.; Phillips, Ivor R.; Lahey, Thomas M. (1994). Fortran 90 Programming (1st ed.). Addison Wesley. ISBN 0-201-54446-6.
Nyhoff, Larry; Sanford Leestma (1995). FORTRAN 77 for Engineers and Scientists with an Introduction to Fortran 90 (4th ed.). Prentice Hall. ISBN 0-13-363003-X.
Press, William H. (1996). Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing. Cambridge, UK: Cambridge University Press. ISBN 0-521-57439-0. http://www.nrbook.com/a/bookf90pdf.php.
Kupferschmid, Michael (2002). Classical Fortran: Programming for Engineering and Scientific Applications. Marcel Dekker (CRC Press). ISBN 0-8247-0802-4.
Akin, Ed (2003). Object Oriented Programming via Fortran 90/95 (1st ed.). Cambridge University Press. ISBN 0-521-52408-3.
Chapman, Stephen J. (2003). Fortran 90/95 for Scientists and Engineers (2nd ed.). McGraw-Hill. ISBN 0-07-282575-8.
Metcalf, Michael; John Reid, Malcolm Cohen (2004). Fortran 95/2003 Explained. Oxford University Press. ISBN 0-19-852693-8.
Chivers, Ian; Sleightholme, Jane (2006). Introduction to Programming with Fortran (1st ed.). Springer. ISBN 1-84628-053-2.
Chapman, Stephen J. (2007). Fortran 95/2003 for Scientists and Engineers (3rd ed.). McGraw-Hill. ISBN 978-0-07-319157-7.
[edit]External links

	Wikibooks has a book on the topic of
Fortran
	Wikiquote has a collection of quotations related to: Fortran
JTC1/SC22/WG5 — The ISO/IEC Fortran Working Group
History of FORTRAN at the Computer History Museum's Software Preservation Group
Bemer, Bob, "Who Was Who in IBM's Programming Research? -- Early FORTRAN Days", January 1957, Computer History Vignettes
Comprehensive Fortran Standards Documents from the gfortran project
Fortran IV - IBM System/360 and System/370 Fortran IV Language - GC28-6515-10
Fortran 77, 90, 95, 2003 Information & Resources
Fortran 77 4.0 Reference Manual
Fortran 90 Reference Card
Categories: Fortran | Array programming languages | Procedural programming languages | Numerical programming languages | Object-oriented programming languages | Parallel computing | Fortran programming language family | Computer and telecommunication standards | Unix programming tools | Statically typed programming languages | Programming languages created in the 1950s
